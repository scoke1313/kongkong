<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>콩콩춘식 - 규격 발판 적용</title>
    <script src="https://unpkg.com/@rive-app/canvas@latest"></script>
    <style>
        body { margin: 0; background: #333; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        #game-stage { 
            position: relative; 
            width: 393px; 
            height: 852px; 
            background: #fff; 
            overflow: hidden; 
        }
        #canvas-container {
            position: absolute;
            width: 86px;
            height: 138px;
            bottom: 100px; 
            left: 50%;
            margin-left: -43px; 
            z-index: 10;
        }
        canvas { width: 100%; height: 100%; }
        
        /* 발판 기본 스타일 */
        .platform {
            position: absolute;
            background: #5c3e34; /* 나중에 이미지가 들어갈 자리 */
            border-radius: 4px;
            box-sizing: border-box;
            border: 2px solid #3d2b24;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 10px;
            font-family: sans-serif;
        }
    </style>
</head>
<body>

<div id="game-stage">
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
</div>

<script>
// --- 물리 및 규격 파라미터 ---
const PHYSICS = {
    gravity: 0.81,      
    jumpPower: -18.9,   
    moveSpeed: 7,
    stageWidth: 393,
    stageHeight: 852,
    motionHold: 12
};

// 요청하신 세 종류의 발판 사이즈
const PLATFORM_SIZES = [
    { w: 139, h: 24 },
    { w: 99, h: 24 },
    { w: 59, h: 24 }
];

let currentY = 0;        
let velocityY = 0;
let posX = 0;            
let riveInstance;
let keys = {};           
let currentScale = 1;    
let platforms = [];
let motionTimer = 0;
let lastLoadedFile = "";

function loadRive(fileName) {
    if (lastLoadedFile === fileName) return;
    lastLoadedFile = fileName;
    if (riveInstance) riveInstance.cleanup();
    riveInstance = new rive.Rive({
        src: fileName,
        canvas: document.getElementById('canvas'),
        autoplay: true,
        stateMachines: 'State Machine 1',
        onLoad: () => { riveInstance.resizeDrawingSurfaceToCanvas(); }
    });
}

// 발판 생성 로직 (사이즈 랜덤 선택)
function createPlatformData(yPos) {
    const size = PLATFORM_SIZES[Math.floor(Math.random() * PLATFORM_SIZES.length)];
    return {
        x: Math.random() * (PHYSICS.stageWidth - size.w),
        y: yPos,
        w: size.w,
        h: size.h
    };
}

function initPlatforms() {
    platforms = [];
    for (let i = 0; i < 8; i++) {
        platforms.push(createPlatformData(i * 110 + 50));
    }
    // 시작 발판은 넉넉하게 139 사이즈로 고정
    platforms.push({ x: PHYSICS.stageWidth/2 - 69.5, y: 752, w: 139, h: 24 }); 
}

loadRive('kongsik_ingame_air.riv');
initPlatforms();

function update() {
    // 1. 이동
    if (keys['ArrowLeft']) { posX -= PHYSICS.moveSpeed; currentScale = -1; }
    if (keys['ArrowRight']) { posX += PHYSICS.moveSpeed; currentScale = 1; }
    
    const limit = (PHYSICS.stageWidth / 2) - 43;
    if (posX < -limit) posX = -limit;
    if (posX > limit) posX = limit;

    // 2. 물리
    velocityY += PHYSICS.gravity;
    currentY += velocityY;

    // 3. 모션 관리
    if (motionTimer > 0) {
        motionTimer--;
        if (motionTimer < PHYSICS.motionHold - 2) {
            loadRive('kongsik_ingame_air.riv');
        }
    } else if (velocityY > 2) {
        loadRive('kongsik_ingame_land.riv');
    }

    // 4. 발판 충돌 (p.w 값을 사용하여 동적 판정)
    const charFootY = 752 + currentY; 
    const charLeft = (393 / 2) + posX - 25;

    if (velocityY > 0) { 
        platforms.forEach(p => {
            if (charLeft + 50 > p.x && charLeft < p.x + p.w &&
                charFootY >= p.y && charFootY <= p.y + p.h) {
                
                loadRive('kongsik_ingame_land.riv');
                
                velocityY = PHYSICS.jumpPower; 
                currentY = p.y - 752; 
                motionTimer = PHYSICS.motionHold; 
            }
        });
    }

    // 5. 무한 스크롤 및 새로운 발판 생성
    if (currentY < -250) {
        let diff = -250 - currentY;
        currentY = -250;
        platforms.forEach(p => {
            p.y += diff;
            if (p.y > PHYSICS.stageHeight) {
                // 화면 아래로 나간 발판을 다시 위로 올리면서 사이즈 랜덤화
                const newData = createPlatformData(0);
                p.y = 0;
                p.x = newData.x;
                p.w = newData.w;
                p.h = newData.h;
            }
        });
    }

    // 6. 추락 시 리셋
    if (charFootY > 950) {
        currentY = 0;
        velocityY = PHYSICS.jumpPower; 
        initPlatforms();
        loadRive('kongsik_ingame_air.riv');
    }

    // 7. 렌더링 적용
    document.getElementById('canvas-container').style.transform = 
        `translate(${posX}px, ${currentY}px) scaleX(${currentScale})`;

    renderPlatforms();
    requestAnimationFrame(update);
}

function renderPlatforms() {
    const stage = document.getElementById('game-stage');
    const existing = document.querySelectorAll('.platform');
    
    // 성능을 위해 개수가 맞으면 스타일만 업데이트 (선택 사항이나 여기선 단순 구현 유지)
    existing.forEach(el => el.remove());
    
    platforms.forEach(p => {
        const div = document.createElement('div');
        div.className = 'platform';
        div.style.left = p.x + 'px';
        div.style.top = p.y + 'px';
        div.style.width = p.w + 'px';
        div.style.height = p.h + 'px';
        
        // 사이즈 구분을 위해 텍스트 표시 (나중에 이미지 넣으면 삭제)
        // div.innerText = p.w; 
        
        stage.appendChild(div);
    });
}

window.addEventListener('keydown', (e) => { keys[e.code] = true; });
window.addEventListener('keyup', (e) => { keys[e.code] = false; });

update();
</script>

</body>
</html>
