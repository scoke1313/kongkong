<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>콩콩춘식 - 컨트롤러 & 배경 패치</title>
    <script src="https://unpkg.com/@rive-app/canvas@latest"></script>
    <style>
        body { margin: 0; background: #333; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        #game-stage { 
            position: relative; 
            width: 393px; 
            height: 852px; 
            background: #FFFDF5; /* 배경 컬러 적용 */
            overflow: hidden; 
        }
        #canvas-container {
            position: absolute;
            width: 86px;
            height: 138px;
            bottom: 100px; 
            left: 50%;
            margin-left: -43px; 
            z-index: 10;
        }
        canvas { width: 100%; height: 100%; }
        
        .platform { position: absolute; background-size: 100% 100%; background-repeat: no-repeat; }

        /* 컨트롤러 스타일 */
        .controller {
            position: absolute;
            width: 80px;
            height: 80px;
            background-size: contain;
            background-repeat: no-repeat;
            z-index: 50;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #btn-left {
            left: 30px;
            bottom: 40px;
            transform: scaleX(-1); /* 왼쪽 버튼 좌우 반전 */
        }
        #btn-right {
            right: 30px;
            bottom: 40px;
        }
        .ctrl-default { background-image: url('controller_Default.png'); }
        .ctrl-pressed { background-image: url('controller_pressed.png'); }
    </style>
</head>
<body>

<div id="game-stage">
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div id="btn-left" class="controller ctrl-default"></div>
    <div id="btn-right" class="controller ctrl-default"></div>
</div>

<script>
const PHYSICS = {
    gravity: 0.81,      
    jumpPower: -18.9,   
    moveSpeed: 7,
    stageWidth: 393,
    stageHeight: 852,
    motionHold: 12,
    minGap: 150,
    maxGap: 190 
};

const PLATFORM_TYPES = {
    wood: ['wood_1.png', 'wood_2.png', 'wood_3.png'],
    block: ['block_1.png', 'block_2.png', 'block_3.png']
};
const SIZES = [138, 98, 58];
const PLATFORM_H = 22;

let currentY = 0, velocityY = 0, posX = 0;
let riveInstance, keys = {}, currentScale = 1;
let platforms = [], motionTimer = 0, lastLoadedFile = "";

// --- 컨트롤러 로직 ---
const btnLeft = document.getElementById('btn-left');
const btnRight = document.getElementById('btn-right');

function handleControl(btn, key, isDown) {
    if (isDown) {
        keys[key] = true;
        btn.classList.remove('ctrl-default');
        btn.classList.add('ctrl-pressed');
    } else {
        keys[key] = false;
        btn.classList.remove('ctrl-pressed');
        btn.classList.add('ctrl-default');
    }
}

// 터치 이벤트
btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); handleControl(btnLeft, 'ArrowLeft', true); });
btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); handleControl(btnLeft, 'ArrowLeft', false); });
btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); handleControl(btnRight, 'ArrowRight', true); });
btnRight.addEventListener('touchend', (e) => { e.preventDefault(); handleControl(btnRight, 'ArrowRight', false); });

// 키보드 연동을 위한 클래스 제어
window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft') handleControl(btnLeft, 'ArrowLeft', true);
    if (e.code === 'ArrowRight') handleControl(btnRight, 'ArrowRight', true);
});
window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft') handleControl(btnLeft, 'ArrowLeft', false);
    if (e.code === 'ArrowRight') handleControl(btnRight, 'ArrowRight', false);
});

// --- 기존 게임 로직 유지 ---
function loadRive(fileName) {
    if (lastLoadedFile === fileName) return;
    lastLoadedFile = fileName;
    if (riveInstance) riveInstance.cleanup();
    riveInstance = new rive.Rive({
        src: fileName,
        canvas: document.getElementById('canvas'),
        autoplay: true,
        stateMachines: 'State Machine 1',
        onLoad: () => { riveInstance.resizeDrawingSurfaceToCanvas(); }
    });
}

function createPlatformData(yPos) {
    const sizeIdx = Math.floor(Math.random() * SIZES.length);
    const width = SIZES[sizeIdx];
    const rand = Math.random();
    const isBlock = rand < 0.25;
    const typeKey = isBlock ? 'block' : 'wood';
    let moveType = (rand > 0.9) ? 'h' : (rand > 0.8 ? 'v' : 'normal');

    return {
        x: Math.random() * (PHYSICS.stageWidth - width),
        y: yPos,
        w: width,
        h: PLATFORM_H,
        img: PLATFORM_TYPES[typeKey][sizeIdx],
        isBlock: isBlock,
        durability: isBlock ? 2 : 999,
        type: moveType,
        speed: (Math.random() * 1.5 + 1) * (Math.random() > 0.5 ? 1 : -1),
        offset: Math.random() * Math.PI * 2,
        initialY: yPos,
        isBroken: false
    };
}

function initPlatforms() {
    platforms = [];
    let lastY = 752;
    for (let i = 0; i < 5; i++) {
        const nextGap = PHYSICS.minGap + Math.random() * (PHYSICS.maxGap - PHYSICS.minGap);
        lastY -= nextGap;
        platforms.push(createPlatformData(lastY));
    }
    platforms.push({ x: PHYSICS.stageWidth/2 - 69, y: 752, w: 138, h: PLATFORM_H, img: 'wood_1.png', isBlock: false, durability: 999, type: 'normal' }); 
}

loadRive('kongsik_ingame_air.riv');
initPlatforms();

function update() {
    if (keys['ArrowLeft']) { posX -= PHYSICS.moveSpeed; currentScale = -1; }
    if (keys['ArrowRight']) { posX += PHYSICS.moveSpeed; currentScale = 1; }
    
    const limit = (PHYSICS.stageWidth / 2) - 43;
    if (posX < -limit) posX = -limit;
    if (posX > limit) posX = limit;

    velocityY += PHYSICS.gravity;
    currentY += velocityY;

    platforms.forEach(p => {
        if (p.isBroken) return;
        if (p.type === 'h') {
            p.x += p.speed;
            if (p.x <= 0 || p.x + p.w >= PHYSICS.stageWidth) p.speed *= -1;
        } else if (p.type === 'v') {
            p.offset += 0.04;
            p.y = p.initialY + Math.sin(p.offset) * 25;
        }
    });

    if (motionTimer > 0) {
        motionTimer--;
        if (motionTimer < PHYSICS.motionHold - 2) loadRive('kongsik_ingame_air.riv');
    } else if (velocityY > 2) {
        loadRive('kongsik_ingame_land.riv');
    }

    const charFootY = 752 + currentY; 
    const charLeft = (393 / 2) + posX - 25;

    if (velocityY > 0) { 
        platforms.forEach(p => {
            if (!p.isBroken && charLeft + 50 > p.x && charLeft < p.x + p.w &&
                charFootY >= p.y && charFootY <= p.y + 15) {
                loadRive('kongsik_ingame_land.riv');
                velocityY = PHYSICS.jumpPower; 
                currentY = p.y - 752; 
                motionTimer = PHYSICS.motionHold; 
                p.durability--;
                if (p.durability <= 0) p.isBroken = true;
            }
        });
    }

    if (currentY < -250) {
        let diff = -250 - currentY;
        currentY = -250;
        platforms.forEach(p => {
            p.y += diff;
            if (p.initialY !== undefined) p.initialY += diff;
            if (p.y > PHYSICS.stageHeight) {
                const highestY = Math.min(...platforms.map(plat => plat.y));
                const nextGap = PHYSICS.minGap + Math.random() * (PHYSICS.maxGap - PHYSICS.minGap);
                const newData = createPlatformData(highestY - nextGap);
                Object.assign(p, newData);
                p.isBroken = false; 
            }
        });
    }

    if (charFootY > 950) {
        currentY = 0; velocityY = PHYSICS.jumpPower; 
        initPlatforms();
        loadRive('kongsik_ingame_air.riv');
    }

    document.getElementById('canvas-container').style.transform = 
        `translate(${posX}px, ${currentY}px) scaleX(${currentScale})`;

    renderPlatforms();
    requestAnimationFrame(update);
}

function renderPlatforms() {
    const stage = document.getElementById('game-stage');
    const existing = document.querySelectorAll('.platform');
    existing.forEach(el => el.remove());
    platforms.forEach(p => {
        if (p.isBroken) return;
        const div = document.createElement('div');
        div.className = 'platform';
        div.style.left = p.x + 'px';
        div.style.top = p.y + 'px';
        div.style.width = p.w + 'px';
        div.style.height = p.h + 'px';
        div.style.backgroundImage = `url('${p.img}')`;
        if (p.isBlock && p.durability === 1) div.style.opacity = '0.7';
        stage.appendChild(div);
    });
}

update();
</script>
</body>
</html>
